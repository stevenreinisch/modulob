«IMPORT state»

«EXTENSION de::dubmas::modulob::generator::templates::Types»
«EXTENSION de::dubmas::modulob::state::StateMachineExtensions»

«EXTENSION org::eclipse::xtend::util::stdlib::io»

«DEFINE main FOR StateMachine»
	«EXPAND stateMachineHeader FOR this»
	«EXPAND stateMachineImpl FOR this»
	«EXPAND stateHandler FOR this»
«ENDDEFINE»

«DEFINE stateMachineHeader FOR StateMachine-»
«FILE this.headerFilePath() + this.className() + ".h"-»
#import "MOBStateMachine.h"

enum {
	«FOREACH this.nodes.typeSelect(State) AS state ITERATOR i SEPARATOR ','-»
		«state.enumLiteral()-» «IF i.counter0 == 0-»= 0 «ENDIF-»
		
	«ENDFOREACH»
};

enum {
	«FOREACH this.relevantTransitions() AS transition ITERATOR i SEPARATOR ','-»
		«transition.enumLiteral()-» «IF i.counter0 == 0-»= 0 «ENDIF-»
		
	«ENDFOREACH»
};

@interface «this.className()» : MOBStateMachine

@end
«ENDFILE»
«ENDDEFINE»

«DEFINE stateMachineImpl FOR StateMachine»
«FILE this.implFilePath() + this.className() + ".m"»
#import "«this.className()».h"

#import "MOBState.h"
#import "MOBTransition.h"

@implementation «this.className()»

- (id)init
{
    self = [super init];
    if (self) {
    
    /*
     * Define the states.
     */ 
    «FOREACH this.nodes.typeSelect(State) AS s-»
        MOBState *«s.name» = [[MOBState new] autorelease];
        «s.name».name = @"«s.name»";
        «s.name».ID = «s.enumLiteral()»;
        «s.name».isInitial = «IF s.isInitial()»YES«ELSE»NO«ENDIF»;
        «s.name».isFinal = «IF s.isFinal()»YES«ELSE»NO«ENDIF»;
        «IF s.duration > 0-»«s.name».duration = «s.duration»;«ENDIF»
        «s.name».entrySelectorName = @"«s.entrySelectorName()»";
        «s.name».exitSelectorName = @"«s.exitSelectorName()»";
        
    «ENDFOREACH»
    
    /*
     * Define transitions.
     */
     «FOREACH this.relevantTransitions() AS t-»
     	MOBTransition *«t.name()»  = [[MOBTransition new] autorelease];
        «t.name()».ID = «t.enumLiteral()»;
        «t.name()».guardSelectorName = @"«t.guardSelectorName()»";
        «t.name()».actionSelectorName = @"«t.actionSelectorName()»";
        
     «ENDFOREACH»
    
    /*
     * Wire states and transitions.
     */
  
     //states -> transitions
     «FOREACH this.nodes.typeSelect(State) AS s-»
     	«IF s.incoming.size > 0»
     		«s.name».incomingTransitions = [NSSet setWithObjects:
     		«FOREACH s.incoming.select(t | !InitialNode.isInstance(t.source)) AS t SEPARATOR ','»
     			«t.name()»
     		«ENDFOREACH»
     		nil];
     	«ENDIF»
     	«IF s.outgoing.size > 0»
     		«s.name».outgoingTransitions = [NSSet setWithObjects:
     		«FOREACH s.outgoing AS t SEPARATOR ','»
     			«t.name()»
     		«ENDFOREACH»
     		nil];
     	«ENDIF»
     	
     «ENDFOREACH»
     
     //transitions -> states
     «FOREACH this.relevantTransitions() AS t»
     	«t.name()».sourceState = «((State)t.source).name»;
     	«t.name()».targetState = «((State)t.target).name»;
     	
     «ENDFOREACH»
     
     
     /*
      * Add states and transitions to this state machine instance.
      */
      «FOREACH this.nodes.typeSelect(State) AS s-»
      	[self.states addObject:«s.name»];
      «ENDFOREACH»
      
      «FOREACH this.relevantTransitions() AS t-»
      	[self.transitions addObject:«t.name()»];
      «ENDFOREACH»
        
    }
    return self;
}

@end
    
«ENDFILE»
«ENDDEFINE»

«DEFINE stateHandler FOR StateMachine»
«FILE this.headerFilePath() + 'P_D_' + this.name + 'StateHandler' + ".h"»
#import <Foundation/Foundation.h>

	@protocol «'P_D_' + this.name + 'StateHandler'» <NSObject>
	@optional

#pragma mark states: entry and exit (optional)

	«FOREACH this.nodes.typeSelect(State) AS s-»
		/*
 		 * «IF s.isInitial()-»INITIAL«ELSEIF s.isFinal()-»FINAL«ENDIF» state «s.name»
 		 */
		- (void) «s.entrySelectorName()»;
		- (void) «s.exitSelectorName()»;
		
	«ENDFOREACH»

#pragma mark -
#pragma mark transitions: actions (optional)
	«EXPAND transitionAction FOREACH this.relevantTransitions()»

	«IF this.deterministicExitStates().size > 0-»
#pragma mark transitions: guards (optional)
		//Guards are optional if state has only one outgoing transition.
		
		«EXPAND transitionGuard FOREACH this.deterministicExitStates().outgoing»
	«ENDIF»

	«IF this.nonDeterministicExitStates().size > 0»
#pragma mark transitions: guards (required)

		@required
		
		«EXPAND transitionGuard FOREACH this.nonDeterministicExitStates().outgoing»
	«ENDIF»
	@end
«ENDFILE»
«ENDDEFINE»

«DEFINE transitionAction FOR Transition»
/*
 * transition «this.name()»
 */
- (void) «this.actionSelectorName()»;

«ENDDEFINE»

«DEFINE transitionGuard FOR Transition»
/*
 * transition «this.name()»
 «IF this.guard.expression != ""»* guard description: «this.guard.expression»«ENDIF»
 */
- (void) «this.guardSelectorName()»;
«ENDDEFINE»
